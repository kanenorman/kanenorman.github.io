---
layout: posts
title: "Arrays (Part IV)"
author: Kane Norman
categories: [programming]
excerpt: Ordered arrays and binary search
order: 6
---

<div class="discussion-content">
  <h4>Introduction</h4>
  <p>
    In our previous discussion on arrays, we highlighted their efficiency in
    accessing data but their relatively slower performance in searching. In this
    post, we will explore how pre-ordering the elements in the array can open
    the door for a faster searching algorithm.
  </p>
  <hr />
  <h4>Ordered Arrays & Binary Search</h4>
  <p>
    An ordered array is a type of array that maintains elements in a specific
    order, either ascending or descending. The advantage of an ordered array
    lies in its ability to make searching for elements more efficient and
    faster. Imagine searching for a specific card in a deck of cards. It would
    be easier and quicker to find the desired card in a sorted deck, compared to
    an unsorted one.
  </p>
  <p>
    In arrays, this concept can be leveraged by using algorithms that take
    advantage of the order of the elements to speed up the search process. One
    such algorithm is the binary search algorithm, which is widely used for
    searching in ordered arrays. The binary search algorithm works by dividing
    the array into smaller subintervals until the desired element is found. With
    each iteration, the number of elements is halved, making it possible to
    quickly find the target element.
  </p>
  <p>
    Heres a quick example to illustrate binary search. Consider searching for
    the value 6 in the ordered array
  </p>

  <p style="text-align: center; font-size: x-large">[ 1, 2, 3, 4, 5, 6, 7 ]</p>
  <p>
    To search for the number 6 in our ordered array, we could estimate its
    position by assuming it to be the midpoint of the array. In our example, the
    actual midpoint turns out to be 4. However, since the array is ordered, we
    know that the number 6 must be located to the right of the midpoint. This
    allows us to eliminate all elements to the left of the midpoint, and we can
    narrow down our search to the right half of the array, excluding the
    midpoint.
  </p>
  <p style="text-align: center; font-size: x-large">
    [ 1, 2, 3, <span style="color: red"><u>4</u></span
    >, 5, 6, 7 ]
  </p>

  <p>
    After eliminating the midpoint and left half of the array, we are left with
    three values. Once again we can estimate using the midpoint and we will see
    that in this iteration we have found the value we are looking for.
  </p>
  <p style="text-align: center; font-size: x-large">
    [ <span style="color: gray"><s>1, 2, 3, 4,</s></span> 5,
    <span style="color: red"><u>6</u></span
    >, 7 ]
  </p>
  <p>In Python, the algorithm can be implemented as such</p>
  <pre>
    {% highlight python %}
from typing import List

def binary_search(array: List[Any], target) -> int:
    """
    Perform binary search on a sorted array to find the index of a target value.
    
    Parameters:
    ----------
    array: List[Any]
        A sorted list of integers or floats.
    target: Any
        The value to search for in the array.
    
    Returns:
    --------
    int
        The index of the target value in the array if found, otherwise -1.

    Example:
    --------
    >>> array = [2, 5, 7, 10, 14, 19, 20]
    >>> target = 10
    >>> binary_search(array, target)
    3

    """
    low = 0
    high = len(array) - 1

    while low <= high:
        middle = (low + high) // 2

        if target == array[middle]:
            return middle

        # If target is larger than midpoint, ignore the left half
        if target > array[middle]:
            low = middle + 1

        # If target is smaller than midpoint, ignore the right half
        if target < array[middle]:
            high = middle - 1

    # Return -1 if match not found
    return -1

    {% endhighlight %}

  </pre>
  <p>
    To help further iterate the idea, here is a helpful GIF that animates
    searching though a small ordered array
  </p>

  <div style="text-align: center">
    <a
      title="Mazen Embaby, CC BY-SA 4.0 &lt;https://creativecommons.org/licenses/by-sa/4.0&gt;, via Wikimedia Commons"
      href="https://commons.wikimedia.org/wiki/File:Binary-search-work.gif"
      target="_blank"
      ><img
        width="50%"
        alt="Binary-search-work"
        src="https://upload.wikimedia.org/wikipedia/commons/c/c1/Binary-search-work.gif"
    /></a>
  </div>

  <hr />
  <h4>Big-O Analysis</h4>

  <div class="table-wrapper">
    <table class="alt">
      <thead>
        <tr>
          <th>Operation</th>
          <th>Time Complexity</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Access</td>
          <td>O(1)</td>
        </tr>
        <tr>
          <td>Insert</td>
          <td>O(n)</td>
        </tr>
        <tr>
          <td>Search</td>
          <td>O(log(n))</td>
        </tr>
        <tr>
          <td>Delete</td>
          <td>O(n)</td>
        </tr>
      </tbody>
    </table>
  </div>
  <p>
    Access to elements in an ordered array is still performed using arithmetic
    operations and knowledge of the base memory address, resulting in constant
    time complexity.
  </p>
  <p>
    The utilization of binary search in an ordered array leads to a significant
    improvement in search operations, reducing the time complexity from O(n) in
    unordered arrays to O(log(n)).
  </p>

  <p>
    Insertion and deletion operations in an ordered array still have a time
    complexity of O(n) because the actual insertion or deletion process still
    requires moving up to n elements to maintain the sequential ordering of the
    data. As an important note, inserting into an ordered array is typically
    slower compared to an unordered one since locating the appropriate insertion
    position precedes the actual insertion of the element.
  </p>
  <hr />
  <h4>Conclusion</h4>

  <p>
    In general, when searching for an element in an ordered array, we can
    continuously divide the array into smaller sections by selecting a midpoint
    and separating the elements into a right and left half. The process is
    repeated on the half that contains the target value until the midpoint
    becomes the value being sought.
  </p>

  <p>
    As expected, it is faster and more systematic to search for values in arrays
    that are ordered, but it comes with a trade-off. The process of inserting a
    new value into an ordered array is slightly slower than in an unordered
    array, as it requires finding the correct position in the order before
    insertion can occur. This makes inserting new elements into an ordered array
    a more time-consuming process, but the benefit of faster searches still
    makes it a useful data structure in certain situations.
  </p>
</div>
