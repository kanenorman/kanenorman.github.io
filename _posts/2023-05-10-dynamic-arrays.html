---
layout: posts
title: "Arrays (Part II)"
author: Kane Norman
categories: [programming]
excerpt: Introduction to dynamic arrays
order: 4
---

<div class="discussion-content">
  <h4>Introduction</h4>
  <p>
    As developers, we often come across scenarios where the number of elements
    we need to store is uncertain or subject to change. In such cases,
    fixed-size arrays may not suffice. This is where dynamic arrays prove to be
    useful. Dynamic arrays offer flexibility by adjusting their size dynamically
    as elements are added or removed. In this post, we will explore the inner
    workings of dynamic arrays, their relationship with fixed-size arrays, and
    analyze Python's list object, which serves as an implementation of a dynamic
    array.
  </p>
  <hr />

  <h4>Resizing an Array for Dynamic Storage</h4>
  <p>
    Picture yourself as a software engineer working for a hotel. Your goal is to
    write code that can keep track of the names of all the visitors staying this
    month To do this, you decide to use an array data structure. However, since
    the number of visitors reserving rooms is uncertain, using a fixed-size
    array becomes problematic as you can't determine the initial size. But don't
    worry! You're a clever programmer and have some ideas up your sleeve.
  </p>
  <p>
    One idea could be to initialize a massive array capable of holding 1 billion
    names, a number much larger than the expected number of visitors for your
    hotel. While this approach would probably ensure enough space to store every
    visitor's name, it would lead to significant memory wastage as most of the
    allocated memory would go unused. Thus, this idea is highly inefficient.
  </p>
  <p>
    Recognizing this, you devise a better approach. You start by initializing an
    array with a small fixed size, let's say 4 elements. You begin filling this
    array with visitor's names until it reaches its maximum capacity. Once it's
    full, you create a new array that is slightly larger and copy the values
    from the old array into the new one. After transferring the values, you can
    delete the old array and continue adding names to the new, larger array
    until it also reaches its maximum capacity. Whenever the array becomes full,
    you repeat this process of creating a new, larger array and copying over the
    existing elements.
  </p>
  <p>
    This approach mirrors the functionality of dynamic arrays. Under the hood,
    dynamic arrays are implemented using a fixed-sized array that is replaced
    with a new array when additional capacity is required. This implementation
    enables dynamic arrays to grow or shrink as needed, making them efficient
    for handling varying amounts of data.
  </p>

  <hr />

  <h4>Impact of Resizing on Performance</h4>
  <p>
    Now that we understand how to resize an array, it's crucial to consider the
    frequency and magnitude of resizing. Resizing an array involves creating a
    new array and copying all values from the old array to the new one,
    resulting in a time complexity of O(n). Therefore, it's important to add
    some extra buffer space when resizing the array, allowing for additional
    elements to be added without frequent resizes. An important thing to note:
    minimizing the number of resizes is essential for optimal performance.
  </p>
  <p>
    Let's imagine an extreme scenario where we increase the size of the
    underlying fixed-size array by one each time we reach its maximum capacity.
    This approach leads to slow performance because we would need to perform an
    O(n) resizing process for every new element added. For example, consider the
    following code snippet:
  </p>
  <pre>
{% highlight python %}
numbers = []
for number in range(100):
   numbers.append(number)
{% endhighlight%}
</pre
  >
  <p>
    The time complexity would be O(n<sup>2</sup>) because we would perform n
    O(n) operations. Although using a fixed progression when resizing may seem
    appealing to avoid wasting extra space in the array, it significantly
    impacts performance. Even with a progression size other than 1, such as 10,
    15, 20, etc., we would still observe this O(n<sup>2</sup>) behavior as the
    array size increases. In fact, the amortized cost for each call to
    <code>append()</code> would be O(n).
  </p>
  <p>
    Instead, it's better to use a geometric progression, such as doubling the
    size of the array each time resizing is required. With this approach, we
    don't resize the array for every new element, resulting in less frequent
    resizes. When a resize is necessary, inserting incurs an O(n) operation, but
    when resizing isn't needed, inserting only requires an O(1) operation.
    Consequently, if we run the same mentioned for loop, our code would run in
    O(n) time, and the amortized cost for each call to
    <code>append()</code> would be O(1).
  </p>
  <p>
    For brevity and simplicity, I won't dive into the mathematical proof in this
    post. For a more in-depth understanding and a mathematical explanation of
    why geometric sequences are generally faster, I recommend reading this
    well-written
    <a
      href="https://www.cs.utexas.edu/~slaberge/docs/topics/amortized/dynamic_arrays/"
      target="_blank"
      >post</a
    >
    by a student at the University of Texas.
  </p>

  <p>
    If what I said above was a little intimidating or mathematically complex
    don't worry. Here's a more simplified visual explanation. Consider the
    illustration below:
  </p>

  <div style="text-align: center">
    <a
      title="Dcoetzee, CC0, via Wikimedia Commons"
      href="https://commons.wikimedia.org/wiki/File:Dynamic_array.svg"
      target="_blank"
      ><img
        width="256"
        alt="Dynamic array"
        src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Dynamic_array.svg/256px-Dynamic_array.svg.png"
    /></a>
  </div>
  <p>
    Each box represents one element in the array. All of the light gray boxes
    with empty values are memory spaces currently used by the array, but no
    value is being stored there. Once the array runs out of these empty spaces,
    it has to add more empty spaces. This is what you observe on the third row
    where we see the turtle. The turtle indicates that the array has to resize
    to accommodate adding a new value, which is a slow operation. In this
    example, you can see that we only have two of these slow "turtle" operations
    because we don't have to resize the array every time we add a new element.
  </p>

  <p>
    If we were to resize the array every time we add a new element, then every
    row would be a slow "turtle" operation. This would significantly impact the
    performance of our program. Therefore, the key takeaway is that we want to
    strike a careful balance in how often we resize the array. Resizing too
    often leads to slower performance due to the time complexity of the resizing
    process. On the other hand, if we make our initial array too big to never
    require resizing, we would end up wasting memory by allocating more space
    than necessary.
  </p>

  <p>
    The goal is to find an optimal resizing strategy that minimizes the number
    of resizes while efficiently utilizing memory. Using a geometric
    progression, such as doubling the size of the array each time it needs to be
    resized, strikes a good balance. This approach allows for fewer resizes as
    the array grows, resulting in better performance compared to resizing for
    every single element. By carefully considering the frequency and magnitude
    of resizing, we can ensure that our program performs efficiently and
    effectively manages memory usage.
  </p>

  <hr />
  <h4>Python List and Dynamic Resizing</h4>
  <p>
    Python lists are an excellent example of dynamic arrays. By observing their
    memory usage, we can confirm that they indeed exhibit resizing behavior. The
    code snippet provided below serves as proof of this resizing behavior in
    Python lists. In the code, we start with an empty list and sequentially
    append the <code>None</code> object. After each append operation, we check
    the size of the list to determine if it has grown.
  </p>
  <pre>
{% highlight python %}
from sys import getsizeof

dynamic_array = []

for _ in range(25):
   dynamic_array.append(None)
   size_in_bytes = getsizeof(dynamic_array)
{% endhighlight%}
</pre
  >

  <p>
    If we plot the results of this code snippet, we can see that the list object
    resizes after lengths 0, 4, 8, 16, and 24. This resizing behavior aligns
    with the expected performance as
    <a
      href="https://github.com/python/cpython/blob/590d7a527d43e4a50fcf74839e516ff7b869434f/Objects/listobject.c#LL67C3-L67C3"
      target="_blank"
      >documented in the Python source code.</a
    >.
  </p>

  <div style="text-align: center">
    <img
      src="{{ '/images/memory-usage-dynamic-array.png' | relative_path}}"
      alt="Plot of bytes used by Python list at various lengths"
      style="max-width: -webkit-fill-available"
      width="60%"
      height="60%"
    />
  </div>

  <p>
    It's interesting to note that Python's resizing method deviates slightly
    from a strict geometric sequence. Instead, it employs a mild approach to
    over-allocation, striking a balance that ensures linear-time amortized
    behavior. If you are familiar with the C language, I encourage you to take a
    detailed look at how Python
    <a
      href="https://github.com/python/cpython/blob/590d7a527d43e4a50fcf74839e516ff7b869434f/Objects/listobject.c#LL45C5-L45C5"
      target="_blank"
      >implements its resize behavior </a
    >.
  </p>
  <hr />
  <h4>Conclusion</h4>
  <p>
    Dynamic arrays emerge as a valuable alternative to fixed-size arrays,
    especially in scenarios where the number of elements to be stored remains
    uncertain. Throughout this exploration, we have unveiled the intricacies of
    dynamic arrays and their performance characteristics, which closely resemble
    those of fixed-size arrays, except during resize operations. While resizing
    incurs an O(n) operation, we have demonstrated that these occurrences are
    infrequent. By adopting carefully crafted resizing methods, such as
    following a geometric sequence, we can achieve an amortized complexity of
    O(1) when appending elements to dynamic arrays. In the next post, we will
    take one more thorough look at the Python list object and discuss the
    difference between referential and compact arrays.
  </p>
</div>
