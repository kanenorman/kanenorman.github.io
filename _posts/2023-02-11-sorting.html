---
layout: posts
title: "Data Structures and Algorithms : Sorting"
author: Kane Norman
categories: [programming]
excerpt: A high level introduction to various sorting methods
---

<div class="discussion-content">
  <h4>Introduction</h4>

  <hr />
  <h4>Bubble Sort</h4>
  <p>
    Bubble sort is easy to implement, but it is a very inefficient sorting
    algorithm. The idea behind bubble sort is easy to understand. The algorithm
    starts by comparing each pair of adjacent elements in the list from the
    left. If an element is larger than the one to its right, the values are
    swapped. This process repeats until the largest elements have "bubbled up"
    to the end of the list. In the first iteration, the largest value will reach
    its final position, and in the next iteration, the second largest will reach
    its position, and so on, until all elements are sorted.
  </p>
  <div style="text-align: center">
    <a
      title="Swfung8, CC BY-SA 3.0 &lt;https://creativecommons.org/licenses/by-sa/3.0&gt;, via Wikimedia Commons"
      href="https://commons.wikimedia.org/wiki/File:Bubble-sort-example-300px.gif"
      ><img
        width="256"
        alt="Bubble-sort-example-300px"
        src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif"
    /></a>
  </div>
  <p>
    In the example above, we have an array with 8 elements. In the first
    iteration, 7 comparisons are made and the biggest value ends up in the last
    position (8th). In the next iteration, we only have to make 6 comparisons
    since the largest value is already at the end of the list. This process
    continues until all elements are sorted in order.
  </p>

  <p>
    In general, for an array containing n values, bubble sort makes n-1
    comparisons during the first iteration, n-2 comparisons in the second
    iteration and so on. The total number of comparisons in the entire sorting
    process can be expressed as the series (n-1) + (n-2) + (n-3) + ... + 1. This
    gives us a time complexity of O(n<sup>2</sup>).
  </p>
  <p>An implementation of the algorithm in Python can be found below</p>
  <pre>
{% highlight python %}
def bubble_sort(array):
    n = len(array)

    # with each iteration, we should place the correct value at the end
    for end in range(n - 1, 0, -1):
        for inner in range(0, end):
            # if current value is bigger than next value then swap positions until we reach the end
            if array[inner] > array[inner + 1]:
                array[inner], array[inner + 1] = array[inner + 1], array[inner]
{% endhighlight %}
  </pre>
  <hr />
  <h4>Selection Sort</h4>
  <p>
    One of the major drawbacks of bubble sort is its slow performance due to the
    numerous intermediate swaps required to sort the values in the array. To
    address this challenge, selection sort can be utilized. This algorithm
    locates the smallest value in the list and moves it to the first position.
    In the next iteration, it finds the second smallest value and places it in
    the second position, and so on. This leads to a more efficient sorting
    process compared to bubble sort.
  </p>
  <div style="text-align: center">
    <a
      title="Joestape89, CC BY-SA 3.0 &lt;http://creativecommons.org/licenses/by-sa/3.0/&gt;, via Wikimedia Commons"
      href="https://commons.wikimedia.org/wiki/File:Selection-Sort-Animation.gif"
      ><img
        width="64"
        alt="Selection-Sort-Animation"
        src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif"
    /></a>
  </div>
  <p>
    Like bubble sort, selection sort also requires (n-k) comparisons in each
    k<sup>th</sup> iteration. Hence, the total number of comparisons in the
    entire sorting process can be expressed as a series: (n-1) + (n-2) + (n-3) +
    ... + 1. This results in a time complexity of O(n<sup>2</sup>). Although the
    number of comparisons in selection sort is similar to bubble sort, selection
    sort is generally faster due to the fact that it requires fewer swaps to be
    made.
  </p>

  <p>An implementation of the algorithm in Python can be found below</p>
  <pre>
{% highlight python %}
def selection_sort(array):
    n = len(array)

    for outer in range(n - 1):
        min_index = outer
        for inner in range(outer + 1, n):
            if array[inner] < array[min_index]:
                min_index = inner

        array[outer], array[min_index] = array[min_index], array[outer]
{% endhighlight %}
  </pre>
</div>
