---
layout: posts
title: "Linked List"
author: Kane Norman
categories: [programming]
excerpt: Singly linked list
order: 8
---

<div class="discussion-content">
  <h4>Introduction</h4>
  <p>
    Linked lists offer an alternative approach to organizing and manipulating
    data in a linear fashion. In this post, our focus will be on a specific
    type of linked list known as a singly linked list. Through this discussion,
    you'll gain a solid understanding of the principles and operations
    underlying singly linked lists. Before reading this post, it is important
    that you have a basic understanding of
    <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)"
      >pointers</a
    >.
  </p>
  <hr />
  <h4>Nodes</h4>
  <p>
    A linked list is a collection of individual units called nodes that are
    connected in a linear sequence. Each node in the linked list contains two
    important pieces of information: a reference to an object that represents an
    element in the sequence, and a reference to the next node in the linear
    sequence.
  </p>

  <div style="text-align: center">
    <figure>
      <a
        title="Vectorization:  Lasindi, Public domain, via Wikimedia Commons"
        href="https://commons.wikimedia.org/wiki/File:Singly-linked-list.svg"
        ><img
          width="40%"
          alt="Singly-linked-list"
          src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/256px-Singly-linked-list.svg.png"
      /></a>
    </figure>
  </div>
  <p>
    The illustration above depicts a specific variant of linked list referred to
    as a singly linked list. It comprises three nodes. The first node, often
    referred to as the "head," contains a reference to the value 12 and points
    to the second node. The second node holds a reference to the value 99 and
    points to the last node, known as the "tail," which contains a reference to
    the value 37. The tail node does not point to any other node, as it marks
    the end of the linked list.
  </p>

  <p>
    To implement a basic version of this linked list in Python, we define a node
    class and create three instances of it: <code>tail</code>,
    <code>middle</code>, and <code>head</code>. Each node contains a reference
    to the data it holds and a reference to the next node in the sequence.
  </p>
  <pre>
    {% highlight python %}
    from __future__ import annotations
    from typing import Any, Union


    class Node:
        def __init__(self, data: Any, next_node: Union[Node, None] = None) -> None:
        """
        Node object for a linked list.

        Parameters
        ----------
        data : Any
            Primary data stored by linked list
        next_node : Node
            Next node in the linear sequence to succeed the current node

        """
        self.data: Any = data
        self.next: Union[Node, None] = next_node

    tail = Node(97)
    middle = Node(99, tail)
    head = Node(12, middle)
    {% endhighlight%}
  </pre>

  <hr />
  <h4>Implementing a Singly Linked List</h4>
  <p>
    A singly linked list is a data structure represented in memory by multiple
    objects "linked" together using pointers. Each node is an individual object
    holding its own data, and a pointer to the next node in the sequence (or
    None if it's the last node). In addition to these nodes, there exists an
    overarching object that acts as the representation of the entire singly
    linked list, ensuring its coherence as a unified entity.
  </p>
  <p>
    The main object, at a minimum, maintains a record of the head node, enabling
    us to start at the head and traverse the sequence to reach the end of the
    singly linked list. To enhance convenience, it's common practice to store
    references to both the head and tail of the list. This avoids the need to
    iterate through each node to find the end. Furthermore, it's also common to
    store the size of the list in a separate variable. This provides quick
    access to the size without the need to count nodes through a complete
    traversal.
  </p>

  <p>
    Python does not have a built-in singly linked list data structure, so we
    will focus on how we can write our own implementation from scratch. As
    always, we will start with defining our <code>__init__</code> method. Here
    we will make two pointers, <code>_head</code> which represents the first
    node in the list and <code>_tail</code> which represents the last node in
    the list. Additionally, we will define an attribute <code>_size</code> that
    keeps track of how many nodes are currently in the list.
  </p>

  <pre>
    {%highlight python%}
    class LinkedList:
        def __init__(self) -> None:
            """A singly linked list implementation with head, tail, and size tracking."""
            self._head = None
            self._tail = None
            self._size = 0
    {%endhighlight%}
  </pre>

  <p>
    Inserting a node at the beginning of our linked list is a straightforward
    process. To accomplish this, we follow these steps:
  </p>
  <ul>
    <li>Create a new node that we want to prepend.</li>
    <li>
      If the list is empty, make the new node both the head and the tail of the
      list.
    </li>
    <li>
      Otherwise, set the <code>next</code> pointer of the new node to the
      current head of the list.
    </li>
    <li>Update the head pointer to point to our new node.</li>
  </ul>
  <p>
    By performing these steps, the new node becomes the new head of the linked
    list, and it is effectively inserted at the beginning.
  </p>

  <pre>
    {%highlight python%}
        def prepend(self, data):
            """
            Prepend a new node with the given data at the beginning of the linked list.

            This method adds a new node containing the provided data to the front of the linked list.
            The new node becomes the new head of the list. 

            Parameters
            ----------
            data : Any
                The data to be stored in the new node.

            Returns
            -------
            None

            Examples
            --------
            >>> linked_list = SinglyLinkedList()
            >>> linked_list.prepend(42)
            >>> linked_list.prepend(27)
            >>> linked_list.prepend(99)
            >>> linked_list.to_list()
            [99, 27, 42]

            """
            new_node = Node(data)
            if self._head is None:
                self._head = new_node
                self._tail = new_node
            else:
                new_node.next = self._head
                self._head = new_node
            self._size += 1
    {%endhighlight%}
  </pre>

  <p>
    Appending a node to the end of our linked list is a very similar process. To
    accomplish this, we follow these steps:
  </p>
  <ul>
    <li>Create a new node that we want to append.</li>
    <li>
      If the list is empty, make the new node both the head and the tail of the
      list.
    </li>
    <li>
      Otherwise, set the <code>next</code> pointer of the current tail to the
      new node.
    </li>
    <li>Update the tail pointer to point to our new node.</li>
  </ul>
  <p>
    By performing these steps, the new node becomes the new tail of the linked
    list, and it is effectively inserted at the end.
  </p>
  <pre>
    {%highlight python%}
    def append(self, data):
        """
        Append a new node with the given data at the end of the linked list.

        This method adds a new node containing the provided data to the end of the linked list.
        The new node becomes the new tail of the list.

        Parameters
        ----------
        data : Any
            The data to be stored in the new node.

        Returns
        -------
        None

        Examples
        --------
        >>> linked_list = SinglyLinkedList()
        >>> linked_list.append(42)
        >>> linked_list.append(27)
        >>> linked_list.append(99)
        >>> linked_list.to_list()
        [42, 27, 99]

        """
        new_node = Node(data)
        if self._head is None:
            # If the linked list is empty, set both head and tail to the new node.
            self._head = new_node
            self._tail = new_node
        else:
            # If the linked list is not empty, link the new node after the current tail.
            self._tail.next = new_node
            # Update the tail to point to the new node, making it the new tail.
            self._tail = new_node
        self._size += 1
    {%endhighlight%}
  </pre>
  <p>
    We can also insert nodes at intermediate positions. The
    <code>insert_after</code> method enables us to insert a new node with the
    provided data into the linked list after a specific node. This operation
    expands the linked list by adding new elements in between existing nodes. To
    accomplish this, we follow these steps:
  </p>
  <ul>
    <li>
      Traverse the linked list, starting from the head node, until we find the
      target node after which we want to insert the new node.
    </li>
    <li>Create a new node with the desired data.</li>
    <li>
      Adjust the <code>next</code> pointers to insert the new node after the
      target node. This involves updating the <code>next</code> pointer of the
      target node to point to the new node, and the <code>next</code> pointer of
      the new node to point to the node originally after the target node.
    </li>
    <li>
      If the target node is the current tail node, update the tail pointer to
      point to the new node.
    </li>
  </ul>
  <p>
    By following these steps, we seamlessly insert the new node into the linked
    list after the desired node, preserving the order and continuity of the
    list.
  </p>
  <pre>
    {%highlight python%}
  def insert_after(self, data, after_data):
      """
      Insert a new node with the given data after the node with the specified data.

      This method adds a new node containing the provided data after the node with
      the specified `after_data` in the linked list.

      Parameters
      ----------
      data : Any
          The data to be stored in the new node.
      after_data : Any
          The data of the desired precursor node after which the new node should be inserted.

      Returns
      -------
      None

      Examples
      --------
      >>> linked_list = SinglyLinkedList()
      >>> linked_list.append(42)
      >>> linked_list.append(27)
      >>> linked_list.insert_after(99, 42)
      >>> linked_list.to_list()
      [42, 99, 27]

      >>> empty_list = SinglyLinkedList()
      >>> empty_list.insert_after("Hello", None)  # Since the list is empty, the new node won't be inserted.
      >>> empty_list.to_list()
      []

      """
      new_node = self.Node(data)
      current = self._head
      while current is not None:
          if current.data == after_data:
              # Insert the new node after the node with the specified data.
              new_node.next = current.next
              current.next = new_node
              if current == self._tail:
                  # If the specified data is the current tail, update the tail to the new node.
                  self._tail = new_node
              self._size += 1
              return
          current = current.next

    {%endhighlight%}
  </pre>

  <p>
    So far, we have learned that inserting nodes into a singly linked list is a
    straightforward process. However, when it comes to deletion, it can be more
    challenging. The difficulty arises from the requirement of knowing both the
    previous node <code>i-1</code> and the next node <code>i+1</code> in order
    to delete node <code>i</code>. This is because deleting node
    <code>i</code> involves connecting node <code>i-1</code> to node
    <code>i+1</code>, effectively removing node <code>i</code>from the list. In
    the case of a singly linked list, we only know the succeeding node. In other
    words, we don't have direct access to node <code>i-1</code>. This limitation
    makes it slightly more difficult to delete nodes in a singly linked list.
  </p>

  <p>
    The <code>delete</code> method allows us to remove the first occurrence of a
    node with the specified data from the linked list. This operation involves
    the following steps:
  </p>
  <ul>
    <li>Start traversing the linked list from the head node.</li>
    <li>
      If the head node itself contains the target data, update the head pointer
      to point to the next node.
    </li>
    <li>
      Otherwise, iterate through the linked list until we find the node
      immediately before the target node.
    </li>
    <li>
      Adjust the <code>next</code> pointer of the preceding node to skip over
      the target node and connect it directly to the node following the target
      node.
    </li>
    <li>
      If the target node is the tail node, update <code>_tail</code> to point to
      the preceding node.
    </li>
  </ul>
  <p>
    By following these steps, the node with the specified data is effectively
    removed from the linked list, and the remaining nodes are properly connected
    to maintain the integrity of the list.
  </p>

  <pre>
    {%highlight python%}
  def delete(self, data):
      """
      Delete the first occurrence of a node with the given data from the linked list.

      This method removes the first node containing the specified `data` from the linked list.

      Parameters
      ----------
      data : Any
          The data referenced by the node to be deleted.

      Returns
      -------
      None

      Examples
      --------
      >>> linked_list = SinglyLinkedList()
      >>> linked_list.append(42)
      >>> linked_list.append(27)
      >>> linked_list.append(99)
      >>> linked_list.delete(27)
      >>> linked_list.to_list()
      [42, 99]

      >>> empty_list = SinglyLinkedList()
      >>> empty_list.delete("Hello")  # Since the list is empty, no changes will be made.
      >>> empty_list.to_list()
      []

      """
      if self._head is None:
          return

      if self._head.data == data:
          # If the node to be deleted is the head, update the head to the next node.
          self._head = self._head.next
          if self._head is None:
              # If the list becomes empty after the deletion, update the tail as well.
              self._tail = None
          self._size -= 1
          return

      current = self._head
      while current.next is not None:
          if current.next.data == data:
              # If the node with the specified data is found, link the current node to the next node.
              current.next = current.next.next
              if current.next is None:
                  # If the node to be deleted is the tail, update the tail to the current node.
                  self._tail = current
              self._size -= 1
              return
          current = current.next

    {%endhighlight%}
  </pre>
  <hr />

  <h4>Big-O Analysis</h4>
  <div class="table-wrapper">
    <table class="alt">
      <thead>
        <tr>
          <th>Operation</th>
          <th>Time Complexity</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Access</td>
          <td>O(n)</td>
        </tr>
        <tr>
          <td>Insert</td>
          <td>O(1)</td>
        </tr>
        <tr>
          <td>Search</td>
          <td>O(n)</td>
        </tr>
        <tr>
          <td>Delete</td>
          <td>O(1)</td>
        </tr>
      </tbody>
    </table>
  </div>

  <p>
    Unlike arrays, linked lists do not support direct access to elements using
    an integer-based index system, which would provide O(1) access. Instead, to
    access the <code>j<sup>th</sup></code> element in a linked list, we need to
    start from the head of the list and iterate <code>j</code> times until we
    reach the desired node.
  </p>
  <p>
    Searching through a linked list can be performed using a linear search
    approach, similar to arrays. To find a specific data value, we start at the
    head node and traverse through the list until we locate the desired data. In
    the worst-case scenario, where the data is located at the end of the list or
    completely absent, the search operation would have a time complexity of
    O(n).
  </p>
  <p>
    Inserting into a linked list is completed in constant time operation. To
    insert a new node, we only need to update a few pointers, without the need
    to move any existing nodes. Unlike arrays, where shifting elements may be
    required to accommodate new elements, linked lists offer insertion without
    shuffling any elements. Due to this characteristic, insertion in a linked
    list can be completed in constant time, denoted as O(1).
  </p>
  <p>
    Deleting a node from a singly linked list can be more challenging than
    inserting or searching. To delete a node, we need to locate its preceding
    node. However, singly linked lists do not store references to their previous
    nodes, making deletion more complex. In the implementation provided, we must
    traverse the list to find the preceding node, resulting in a worst-case time
    complexity of O(n). However, in some common implementations where individual
    nodes are managed without an overarching class, deletion can be achieved in
    constant time O(1) by updating a few pointers directly.
  </p>
  <hr />
  <h4>Linked List vs Arrays</h4>
  <p>
    Linked lists and dynamic arrays share some similarities as linear data
    structures without a fixed size, but it's important to note their key
    differences.
  </p>
  <ul>
    <li>
      Linked lists do not have amortized cases. As discussed in a previous post,
      dynamic arrays require constant resizing to accommodate new elements. This
      resizing operation can be costly, causing worst-case time complexity of
      O(n) for append operations instead of the usual O(1). In contrast, linked
      lists dynamically allocate memory proportional to the number of nodes in
      the list. This means that each append and deletion operation has a
      constant execution time, avoiding amortized cases.
    </li>
  </ul>
  <ul>
    <li>
      In theory, linked lists are faster for insertion. In an array, elements
      need to be shifted to make room for new elements, which could result in
      slower insertion. However, linked lists do not require such shifting,
      making insertion operations theoretically faster.<sup><b>**</b></sup>
    </li>
  </ul>
  <ul>
    <li>
      Arrays offer faster access to data, and random access is supported. In
      contrast, linked lists require traversing the list from the beginning to
      access a specific element, which can be slower for large lists.
    </li>
  </ul>

  <figure>
    <blockquote>
        <sup><b>**</b></sup>
        In theory, linked lists should be faster than arrays for insertion and
        deletion since they don't require the shifting of additional elements.
        However, in practice, arrays often outperform linked lists because
        linked lists must preform a slow linear search to find insertion and
        deletion points. For a detailed explanation of why arrays are often
        better, I recommend watching
        <a
          href="https://www.youtube.com/watch?v=YQs6IC-vgmo&ab_channel=AlessandroStamatto"
          target="_blank"
          >this presentation</a
        >
        from Bjarne Stroustrup, the creator of C++.
    </blockquote>
  </figure>

  <hr />
  <h4>Conclusion</h4>
  <p>
    Linked lists are a widely-used linear data structure, and they are often
    encountered in job interviews as a means to assess a programmer's
    proficiency with pointers. Similar to arrays, linked lists are fundamental
    building blocks of data structures and play a crucial role in implementing
    more complex systems. To make informed decisions about their usage, it is
    important to familiarize yourself with the appropriate scenarios for
    employing linked lists versus arrays. By understanding their characteristics
    and trade-offs, you can leverage the strengths of linked lists, such as
    dynamic resizing and efficient insertion/deletion, when they align with the
    requirements of your problem.
  </p>
</div>
