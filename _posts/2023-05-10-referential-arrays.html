---
layout: posts
title: "Arrays (Part III)"
author: Kane Norman
categories: [programming]
excerpt: Referential vs compact arrays
order: 5
---

<div class="discussion-content">
  <h4>Introduction</h4>
  <p>
    This post aims to provide a concise overview of referential and compact
    arrays, which are crucial concepts to understand, especially when dealing
    with arrays containing
    <a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank"
      >mutable data types</a
    >
    or in high performance computing scenarios. So without further ado, let's
    take a closer look at the differences between referential and compact arrays
    to enhance our understanding of these fundamental concepts.
  </p>

  <hr />

  <h4>Referential Arrays</h4>
  <p>
    When working with list in Python, you may wonder how it accommodates storing
    various data types, such as integers, floats, and strings, within the same
    list while maintaining efficient access. As we've learned, list are dynamic
    arrays, and arrays traditionally store sequential data of the same type to
    ensure consistent element size and speedy data retrieval. So, how does
    Python handle different data types in a list without compromising too much
    performance?
  </p>
  <p>
    The answer lies in the utilization of a specialized array implementation
    known as a referential array. Instead of directly storing the primary data
    within the array itself, referential arrays take a different approach by
    storing references to the data they intend to store. In Python, every object
    is an extension of a
    <a href="https://docs.python.org/3/c-api/structures.html#c.PyObject"
    target="_blank"
      >PyObject</a
    >. Each PyObject is represented by a fixed number of bits (64-bits per
    address) that store the memory address of the referenced data . This design
    allows Python to sequentially store 64-bit objects in the dynamic array and
    provide O(1) access. Although this approach may initially seem
    unconventional, it introduces unique functionality and opens up new
    possibilities namely:
  </p>
  <ul>
    <li>
      <span style="color: purple; font-weight: bold"
        >Flexibility in data types </span
      >: By storing references to the data rather than the data itself,
      referential arrays allow for the storage of various data types within the
      same array. This means you can store integers, floats, strings, and
      objects of different classes in a single array, providing flexibility and
      versatility in data handling.
    </li>
    <li>
      <span style="color: purple; font-weight: bold">Shared data</span>:
      Referential arrays enable multiple arrays or data structures to share the
      same data by storing references to a common set of objects
    </li>
  </ul>

  <p>
    It's important to note that with referential arrays, while the references
    themselves are stored sequentially in the array, the objects they reference
    may not necessarily be sequential. This can be detrimental to performance.
  </p>

  <p>
    Another aspect to consider is the storage of mutable datatypes. For example,
    if a mutable instance is being referenced by two lists and you make a change
    to the instance in one list, the change will also be reflected in the second
    list. This is because each list stores a reference to the object not a copy
    of the object.
  </p>

    <div style="text-align: center">
    <img
      src="{{ '/images/referential-array.png' | relative_path}}"
      alt="Referential Array"
      style="max-width: -webkit-fill-available"
      width="60%"
      height="60%"
    />
  </div>
  <hr />

  <h4>Compact Arrays</h4>
  <p>
    Compact arrays are the easier of the two to conceptually understand and are
    a little more intuitive. In a compact array, the primary data is stored
    directly within the array itself, eliminating the need for accessing it via
    a stored reference. This means that each element in the array holds the
    actual data value. However, there is a crucial requirement for maintaining
    uniformity in the array: all elements must be of the same data type. By
    enforcing this constraint, the elements can be stored evenly and
    consistently, ensuring uniform size and proper alignment within the array.
  </p>

  <p>
    Compact arrays offer better efficiency and performance compared to
    referential arrays primarily for two reasons:
  </p>

  <ul>
    <li>
      <span style="color: purple; font-weight: bold">Memory efficiency:</span>
      Compact arrays store the actual data directly in the array, without the
      need for additional memory to store references. This results in reduced
      memory overhead compared to referential arrays, where memory is allocated
      for both the array itself and the references to the data. By eliminating
      the need for references, compact arrays optimize memory usage and can
      store a larger number of elements within a given memory space.
    </li>

    <li>
      <span style="color: purple; font-weight: bold">Direct data access:</span>
      Compact arrays provide direct access to the data without the need for
      following references. This allows for faster and more efficient data
      retrieval since there are no additional steps involved in dereferencing
      the references. In contrast, referential arrays require an extra level of
      dereferencing to access the actual data, which can introduce some overhead
      and slightly slower access times
    </li>
  </ul>

      <div style="text-align: center">
    <img
      src="{{ '/images/compact-array.png' | relative_path}}"
      alt="Compact Array"
      style="max-width: -webkit-fill-available"
      width="60%"
      height="60%"
    />
  </div>

  <hr />
  <h4>Conclusion</h4>
  <p>
    It's crucial to discern whether your array stores references or copies of
    the primary data itself. This distinction significantly affects performance
    and can potentially introduce bugs in your code, particularly when dealing
    with mutable objects. Therefore, gaining a clear understanding of this
    concept is paramount to ensure optimal performance and avoid potential
    pitfalls.
  </p>
</div>
