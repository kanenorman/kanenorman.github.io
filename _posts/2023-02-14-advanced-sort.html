---
layout: posts
title: "Data Structures and Algorithms : Advanced Sorting"
author: Kane Norman
categories: [programming]
excerpt: More sophisticated sorting algorithms
---

<div class="discussion-content">
  <h4>Introduction</h4>
  <p>
    In a previous post,we discussed three simple sorting algorithms: bubble
    sort, selection sort, and insertion sort. Although all of these algorithms
    have a worst-case time complexity of O(n<sup>2</sup>), we acknowledged that
    insertion sort is the most efficient among them. This is because the
    algorithm is designed in a way that allows for fewer comparisons to be made
    with each iteration. As a result, insertion sort performs relatively better
    than the other simple sorting algorithms, particularly when the array is
    already almost sorted.
  </p>

  <p>
    Insertion sort is inefficient when many shifts are required to insert an
    element. Consider the following example where the smallest element is on the
    far right of the array. In this scenario, we would have to copy and shift
    elements 2, 3, 4, 5, and 6 just to insert a single value.
  </p>
  <p style="text-align: center; font-size: x-large">
    [ 2, 3, 4, 5, 6, <span style="color: red"><u>1</u></span> ]
  </p>
  <p>
    Now, consider this example where the element is only slightly out of place.
    We would only have to copy and shift a single element to sort the entire
    array.
  </p>
  <p style="text-align: center; font-size: x-large">
    [ 2, <span style="color: red"><u>1</u></span
    >, 3, 4, 5, 6 ]
  </p>
  <p>
    As we've seen, the efficiency of insertion sort depends on how close the
    array is to being sorted. If the array is far from sorted, the worst-case
    time complexity is O(n<sup>2</sup>). However, if the array is almost sorted,
    the time complexity is closer to O(n). In other words, insertion sort only
    becomes inefficient when elements far from their final position require
    shifting a lot of intermediate elements.
  </p>
  <p>
    To address this issue, we can use shell sort, which is an algorithm that
    sorts elements that are spaced far apart before sorting elements that are
    close together. This approach allows the algorithm to quickly move elements
    that are far from their correct position closer to their sorted position
    without requiring the shifting of a large number of intermediate elements,
    making the sorting process faster and more efficient.
  </p>
  <hr />
  <h4>Shell Sort</h4>
  <p>
    The shell sort algorithm starts by sorting elements that are spaced far
    apart using a certain gap sequence "h". In each iteration, the gap is
    reduced until it reaches one. This way, the algorithm can quickly move
    elements that are far from their correct position closer to their sorted
    position. Once the gap is reduced to one, the algorithm performs a standard
    insertion sort on the entire array, which is now close to being sorted. This
    approach leads to a faster sorting process compared to insertion sort
    because elements are moved closer to their final position more quickly.
  </p>

  <div style="text-align: center">
    <img src="{{"/images/shellsort.gif"| relative_url}}" alt="shell sort
    animation">
  </div>

  <p>
    In order to effectively implement the shell sort algorithm, it's crucial to
    understand gap sequences that define the spacing between elements being
    compared in each iteration. Various gap sequences are available, including
    Sedgewick, Knuth, and Donald Shell's original sequence. The choice of
    sequence significantly affects the algorithm's efficiency, and extensive
    research has been conducted on the subject. Interested readers are
    encouraged to explore further. For the sake of simplicity and to keep things
    brief, we'll focus specifically on implementing using the Knuth Sequence.
  </p>
  <p>
    The Knuth sequence is a sequence of integers defined recursively by the
    formula:
    <span class="math inline">
      <em>h<sub>i</sub></em> = 3<em>h<sub>i-1</sub></em> + 1
    </span>
    where
    <span class="math inline"
      ><em>h<sub>0</sub></em> = 1</span
    >. The first several terms of the sequence are 1, 4, 13, 40, 121, 364, and
    1093. It's important to note that you should only use values of
    <em>h<sub>i</sub></em> that are less than the size of your array. For
    example, if your array has 500 elements, you should only use values of
    <em>h<sub>i</sub></em> up to 364.
  </p>

  <p>
    Below is an implementation of the algorithm in Python. You will notice that
    it is essentially the same as shell sort, but includes the gap sequence
    described above.
  </p>
  <pre>
  {%highlight python%}
def shell_sort(array):
  n = len(array)
  knuth = lambda h: 3 * h + 1
  inverse_knuth = lambda h: (h - 1) // 3

  # build Knuth sequence
  h = 1
  while knuth(h) < n:
      h = knuth(h)

  while h > 0:
      for outer in range(h, n):
          value = array[outer]
          inner = outer

          # same logic as insertion sort
          while inner >= h and value < array[inner - h]:
              array[inner] = array[inner - h]
              inner -= h

          array[inner] = value

      # decrement the gap
      h = inverse_knuth(h)
  {%endhighlight%}
  </pre>

  <p>
    The average complexity of this algorithm is rather complex to derive. For
    now, just know the implementation that is shown above has an average run
    time complexity of O(n(log(n))<sup>2</sup>), and a worst-case complexity of
    O(n<sup>3/2</sup>).
  </p>

  <hr>
  <h4>Quick Sort</h4>
</div>
